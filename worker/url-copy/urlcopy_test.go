/*
* Copyright (c) CERN 2016
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
 */

package main

import (
	"encoding/json"
	"github.com/Sirupsen/logrus"
	"github.com/golang/protobuf/ptypes/duration"
	"gitlab.cern.ch/flutter/fts/messages"
	"gitlab.cern.ch/flutter/go-dirq"
	"io/ioutil"
	"os"
	"path"
	"syscall"
	"testing"
	"time"
)

func init() {
	*logToStderr = true
	*dirqBasePath = "/tmp/url_copy_tests/lib"
	*logBaseDir = "/tmp/url_copy_tests/log"
	logrus.SetLevel(logrus.FatalLevel)

	os.RemoveAll(*dirqBasePath)
	os.RemoveAll(*logBaseDir)
}

// Serialize serializes the task into a temporary file, so it can be passed to the
// copy function.
func Serialize(t *testing.T, task *messages.Batch) string {
	bytes, err := json.Marshal(task)
	if err != nil {
		t.Error(err)
	}

	f, err := ioutil.TempFile(os.TempDir(), "url_copy")
	if err != nil {
		t.Error(err)
	}

	f.Write(bytes)
	f.Close()
	return f.Name()
}

// ConsumeStartMessages reads the start messages generated by url_copy
func ConsumeStartMessages(t *testing.T) *messages.Batch {
	batches := make([]*messages.Batch, 0, 10)

	startDirq, err := dirq.New(path.Join(*dirqBasePath, "start"))
	if err != nil {
		t.Error(err)
	}

	for msg := range startDirq.Consume() {
		if msg.Error == nil {
			batch := &messages.Batch{}
			err = json.Unmarshal(msg.Message, batch)
			if err != nil {
				t.Error(err)
			} else {
				batches = append(batches, batch)
			}
		} else {
			t.Error(msg.Error)
		}
	}

	if len(batches) != 1 {
		t.Fatal("Expecting only one batch")
	}
	return batches[0]
}

// ConsumeEndMessages reads the end messages generated by url_copy
func ConsumeEndMessages(t *testing.T) *messages.Batch {
	batches := make([]*messages.Batch, 0, 10)

	endDirq, err := dirq.New(path.Join(*dirqBasePath, "end"))
	if err != nil {
		t.Error(err)
	}

	for msg := range endDirq.Consume() {
		if msg.Error == nil {
			batch := &messages.Batch{}
			err = json.Unmarshal(msg.Message, batch)
			if err != nil {
				t.Error(err)
			} else {
				batches = append(batches, batch)
			}
		} else {
			t.Error(msg.Error)
		}
	}

	if len(batches) != 1 {
		t.Fatal("Expecting only one batch")
	}
	return batches[0]
}

// Test a simple transfer, with two files, default timeout (which is long enough)
// Once the transfer is finished, there must be one start message, and one end message.
func TestSimpleTransfer(t *testing.T) {
	transfer := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=1",
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 1 {
		t.Error("Expecting 1 start message, got", len(start.Transfers))
		return
	}
	if len(end.Transfers) != 1 {
		t.Error("Expecting 1 end message, got", len(end.Transfers))
		return
	}

	if start.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on start message does not match submitted")
		t.Log(start)
		t.Log(transfer)
	}
	if end.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on end message does not match submitted")
		t.Log(end)
		t.Log(transfer)
	}
	if end.Transfers[0].State != messages.Transfer_FINISHED {
		t.Error("Expecting Finished, got", end.Transfers[0].State)
	}
	if end.Transfers[0].Info.Error != nil {
		t.Error("Expecting success, got", end.Transfers[0].Info.Error.Description)
	}
	if end.Transfers[0].Info.Stats.Transferred != 10 {
		t.Error("Expecting filesize to be reported 10, got", end.Transfers[0].Info.Stats.Transferred)
	}
}

// Test the Panic method without running. There must be one end message after the fact.
func TestPanic(t *testing.T) {
	transfer := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=1",
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Panic("TEST PANIC MESSAGE")

	end := ConsumeEndMessages(t)

	if len(end.Transfers) != 1 {
		t.Error("Expecting 1 end message, got", len(end.Transfers))
		return
	}

	if end.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on end message does not match submitted")
		t.Log(end)
		t.Log(transfer)
	}

	if end.Transfers[0].State != messages.Transfer_FAILED {
		t.Error("Expecting Failed, got", end.Transfers[0].State)
	}

	if end.Transfers[0].Info.Error == nil {
		t.Error("Expecting an error, got none")
	} else if end.Transfers[0].Info.Error.Code != int32(syscall.EINTR) {
		t.Error("Expecting EINTR, got", end.Transfers[0].Info.Error.Code)
	} else if end.Transfers[0].Info.Error.Description != "TEST PANIC MESSAGE" {
		t.Error("Unexpected error message, got", end.Transfers[0].Info.Error.Description)
	}
}

// Test cancelling a file transfer in the middle of it.
// There must be one start and one end messages. The end message must be set properly.
func TestCancel(t *testing.T) {
	transfer := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=5",
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	go func() {
		time.Sleep(1 * time.Second)
		copy.Cancel()
	}()
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 1 {
		t.Error("Expecting 1 start message, got", len(start.Transfers))
		return
	}
	if len(end.Transfers) != 1 {
		t.Error("Expecting 1 end message, got", len(end.Transfers))
		return
	}

	if end.Transfers[0].State != messages.Transfer_CANCELED {
		t.Error("Expecting Canceled, got", end.Transfers[0].State)
	}

	if start.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on start message does not match submitted")
		t.Log(start)
		t.Log(transfer)
	}
	if end.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on end message does not match submitted")
		t.Log(end)
		t.Log(transfer)
	}
	if end.Transfers[0].Info.Error == nil {
		t.Error("Expecting an error, got success")
		return
	} else if end.Transfers[0].Info.Error.Code != int32(syscall.ECANCELED) {
		t.Error("Expecting ECANCELED, got", end.Transfers[0].Info.Error.Code)
	}
}

// Test the timeout function. Set a shorter timeout than the time it will take to transfer.
// The transfer must finish with a timeout end message.
func TestTimeout(t *testing.T) {
	transfer := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=10",
		Parameters: &messages.TransferParameters{
			Timeout: &duration.Duration{Seconds: 1},
		},
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 1 {
		t.Error("Expecting 1 start message, got", len(start.Transfers))
		return
	}
	if len(end.Transfers) != 1 {
		t.Error("Expecting 1 end message, got", len(end.Transfers))
		return
	}

	if start.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on start message does not match submitted")
		t.Log(start)
		t.Log(transfer)
	}
	if end.Transfers[0].TransferId != transfer.TransferId {
		t.Error("Received transfer on end message does not match submitted")
		t.Log(end)
		t.Log(transfer)
	}
	if end.Transfers[0].State != messages.Transfer_FAILED {
		t.Error("Expecting Failed, got", end.Transfers[0].State)
	}
	if end.Transfers[0].Info.Error == nil {
		t.Error("Expecting an error, got success")
	} else if end.Transfers[0].Info.Error.Code != int32(syscall.ETIMEDOUT) {
		t.Error("Expecting ETIMEDOUT, got", end.Transfers[0].Info.Error.Code)
	}
}

// Test a simple bulk job: two transfers in one url_copy process. There must be two
// start and two end messages, both succesful.
func TestMultipleSimple(t *testing.T) {
	transfer1 := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=1",
	}
	transfer2 := &messages.Transfer{
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      "mock://host/path?size=42",
		Destination: "mock://host/path?size_post=42&time=1",
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		return
	}

	if end.Transfers[0].State != messages.Transfer_FINISHED {
		t.Error("Expecting Finished, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.Transfer_FINISHED {
		t.Error("Expecting Finished, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error != nil {
		t.Error("First transfer expected success, got", end.Transfers[0].Info.Error.Description)
		return
	}
	if end.Transfers[1].Info.Error != nil {
		t.Error("Second transfer expected success, got", end.Transfers[1].Info.Error.Description)
		return
	}

	if end.Transfers[0].Info.Stats.Transferred != 10 {
		t.Error("File size for transfer 1 does not match. Got", end.Transfers[0].Info.Stats.Transferred)
	}
	if end.Transfers[1].Info.Stats.Transferred != 42 {
		t.Error("File size for transfer 2 does not match. Got", end.Transfers[1].Info.Stats.Transferred)
	}
}

// Test a bulk task, and cancel after a while, giving time to the first transfer to finish.
// There must be two start and two end messages. The first one must be successful and the second one
// must be failed with ECANCELED.
func TestMultipleCancel(t *testing.T) {
	transfer1 := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=2",
	}
	transfer2 := &messages.Transfer{
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      "mock://host/path?size=42",
		Destination: "mock://host/path?size_post=42&time=10",
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	go func() {
		time.Sleep(4 * time.Second)
		copy.Cancel()
	}()
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		return
	}

	if end.Transfers[0].State != messages.Transfer_FINISHED {
		t.Error("Expecting Finished, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.Transfer_CANCELED {
		t.Error("Expecting Canceled, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error != nil {
		t.Error("First transfer expecting success, got", end.Transfers[0].Info.Error.Description)
	}
	if end.Transfers[1].Info.Error == nil {
		t.Error("Second transfer expecting failure, got success")
	} else if end.Transfers[1].Info.Error.Code != int32(syscall.ECANCELED) {
		t.Error("Second transfer expecting ECANCELED, got", end.Transfers[1].Info.Error.Code)
	}
}

// Similar to the cancel test, but this time trigger a Panic, which normally would be
// called by the signal handler. The process normally would terminate immediately, but an
// end message must have been generated.
func TestMultiplePanic(t *testing.T) {
	transfer1 := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      "mock://host/path?size=10",
		Destination: "mock://host/path?size_post=10&time=2",
	}
	transfer2 := &messages.Transfer{
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      "mock://host/path?size=42",
		Destination: "mock://host/path?size_post=42&time=5",
	}

	task := &messages.Batch{
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	go func() {
		time.Sleep(3 * time.Second)
		copy.Panic("Signal 386")
	}()
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		return
	}

	if end.Transfers[0].State != messages.Transfer_FINISHED {
		t.Error("Expecting Finished, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.Transfer_FAILED {
		t.Error("Expecting Failed, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error != nil {
		t.Error("First transfer expecting success, got", end.Transfers[0].Info.Error.Description)
	}
	if end.Transfers[1].Info.Error == nil {
		t.Error("Second transfer expecting failure, got success")
	} else if end.Transfers[1].Info.Error.Code != int32(syscall.EINTR) {
		t.Error("Second transfer expecting EINTR, got", end.Transfers[1].Info.Error.Code)
	}
}

/*
THESE TESTS ARE DISABLED
// Test a multihop transfer. Since the first hop fails, the second must not run, even though it would
// success.
func TestMultiHop(t *testing.T) {
	transfer1 := &messages.Transfer{
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10&errno=2"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}
	transfer2 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=42"),
		Destination: surlHelper("mock://host/path?size_post=42&time=2"),
	}

	task := &messages.Batch{
		Type:      messages.BatchMultihop,
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		t.Log(start)
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		t.Log(end)
		return
	}

	if end.Transfers[0].State != messages.TransferFailed {
		t.Error("Expecting Failed, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.TransferFailed {
		t.Error("Expecting Failed, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error == nil {
		t.Error("First transfer expecting failure, got success")
	} else if end.Transfers[0].Info.Error.Code != syscall.ENOENT {
		t.Error("First transfer expecting ENOENT, got", end.Transfers[0].Info.Error.Code)
	}
	if end.Transfers[1].Info.Error == nil {
		t.Error("Second transfer expecting failure, got success")
	} else if end.Transfers[1].Info.Error.Code != syscall.ECANCELED {
		t.Error("Second transfer expecting ECANCELED, got", end.Transfers[0].Info.Error.Code)
	}
}

// Test a multihop transfer. The first succeeds, but the second should be pushed to the queue by the scheduler.
func TestMultiHop2(t *testing.T) {
	transfer1 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}
	transfer2 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}

	task := &messages.Batch{
		Type:      messages.BatchMultihop,
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		t.Log(start)
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		t.Log(end)
		return
	}

	if end.Transfers[0].State != messages.TransferFinished {
		t.Error("Expecting Finished, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.TransferOnHold {
		t.Error("Expecting On Hold, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error != nil {
		t.Error("First transfer expecting success, got", end.Transfers[0].Info.Error)
	}
	if end.Transfers[1].Info.Error != nil {
		t.Error("Second transfer expecting no error, got", end.Transfers[1].Info.Error)
	}
}

// Test a multiple source batch
// It is not up to url copy to run the remaining options
func TestMultisources(t *testing.T) {
	transfer1 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10&errno=2"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}
	transfer2 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}

	task := &messages.Batch{
		Type:      messages.BatchMultisource,
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		t.Log(start)
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		t.Log(end)
		return
	}

	if end.Transfers[0].State != messages.TransferFailed {
		t.Error("Expecting Failed, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.TransferOnHold {
		t.Error("Expecting On Hold, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error == nil {
		t.Error("First transfer expecting failure, got success")
	} else if end.Transfers[0].Info.Error.Code != syscall.ENOENT {
		t.Error("First transfer expecting ENOENT, got", end.Transfers[0].Info.Error.Code)
	}
	if end.Transfers[1].Info.Error != nil {
		t.Error("Second transfer expecting no failure, got", end.Transfers[1].Info.Error)
	}
}

// Test a multiple source batch where the current step succeeds
func TestMultisources2(t *testing.T) {
	transfer1 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "e0ccca86-2279-11e6-9c7b-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}
	transfer2 := &messages.Transfer{
		JobID:       "d025fb26-2279-11e6-a607-02163e006dd0",
		TransferId:  "1e97ce14-227b-11e6-81e2-02163e006dd0",
		Source:      surlHelper("mock://host/path?size=10"),
		Destination: surlHelper("mock://host/path?size_post=10&time=2"),
	}

	task := &messages.Batch{
		Type:      messages.BatchMultisource,
		Transfers: []*messages.Transfer{transfer1, transfer2},
	}

	path := Serialize(t, task)
	copy := newURLCopy(path)
	copy.Run()

	start := ConsumeStartMessages(t)
	end := ConsumeEndMessages(t)

	if len(start.Transfers) != 2 {
		t.Error("Expecting 2 start message, got", len(start.Transfers))
		t.Log(start)
		return
	}
	if len(end.Transfers) != 2 {
		t.Error("Expecting 2 end message, got", len(end.Transfers))
		t.Log(end)
		return
	}

	if end.Transfers[0].State != messages.TransferFinished {
		t.Error("Expecting Finished, got", end.Transfers[0].State)
	}
	if end.Transfers[1].State != messages.TransferUnused {
		t.Error("Expecting Unused, got", end.Transfers[1].State)
	}

	if end.Transfers[0].Info.Error != nil {
		t.Error("First transfer expecting success, got", end.Transfers[0].Info.Error)
	}
	if end.Transfers[1].Info.Error != nil {
		t.Error("Second transfer expecting no failure, got", end.Transfers[1].Info.Error)
	}
}
*/
